<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PrinciplesRevisited | maque.onlyverse]]></title>
  <link href="http://maque.github.io/blog/categories/principlesrevisited/atom.xml" rel="self"/>
  <link href="http://maque.github.io/"/>
  <updated>2014-04-20T10:36:31+01:00</updated>
  <id>http://maque.github.io/</id>
  <author>
    <name><![CDATA[maque]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DRY Computation]]></title>
    <link href="http://maque.github.io/blog/2014/03/12/dry-computation/"/>
    <updated>2014-03-12T17:09:13+00:00</updated>
    <id>http://maque.github.io/blog/2014/03/12/dry-computation</id>
    <content type="html"><![CDATA[<p>There is this one nice &amp; simple principle: don’t repeat yourself. Basically you shouldn’t repeat your code if you can create more generic method, after all it’s good for code maintainability.</p>

<p>But being to DRY on your side can easily cause strange behavior. Recently I’ve noticed really weird behavior of SQL Management Studio. If you will open lots of tabs and close them, you will see what i mean – whole SQL MS window is jumping like a tiger from Winnie the pooh.</p>

<p>Let’s imagine for a moment how this could happen because of following DRY principle .</p>

<p>We’re starting with something simple. We create a function for closing one tab:</p>

<p>``` c#</p>

<pre><code>private void DisposeTab(Tab tab){
  //release allocated memory
  //a lot of different stuff that is needed in this place
  AllTabs.Remove(tab);
}

private void CloseTab(Tab tab){
   DisposeTab(tab);
   RedrawWindow();
}
</code></pre>

<p>```</p>

<p>It’s nice, it’s simple and int works. Now we need second function for closing all tabs at once. And we now that already we have function for closing one Tab. We wanted to stay DRY and created something like this:</p>

<p>```</p>

<pre><code>private void ClosseAllTabs(){
  foreach(Tab tab in AllTabs){
      CloseTab(tab);
  }
}
</code></pre>

<p>```</p>

<p>And I’m like 100% sure that it is what is happening in SQL MS. Window is jumping because it’s refresh itself for each closed tab instead of waiting for closing them all and then re-draw window. Code look like DRY but actually it is unnecessary repeated in loop. We should not only avoid code repeating but also avoid repeating computation.</p>

<p>Maybe you remember about that when you are dealing with getting all rows from database, maybe you remember about that with advanced computation – compute them once and put into table. But as MS SQL example shows it is easy to forgot when dealing with simpler things.</p>

<p>I found it’s very useful to start opposite way – writing function for dealing with list or array of items instead of one item. For this example it would be something like that:</p>

<p>```
private void DisposeTab(Tab tab){
  //release allocated memory
  //a lot of different stuff that is needed in this place
  AllTabs.Remove(tab);
}
private void CloseTabs(List<Tab> tabs){
  foreach(Tab tab in tabs){</p>

<pre><code>  DisposeTab(tab);
</code></pre>

<p>  }
  RedrawWindow();
}</p>

<p>private void CloseTab(Tab tab){
  CloseTabs(new List<Tab>{tab});
}</p>

<p>private void ClosseAllTabs(){
  CloseTabs(AllTabs);
}
```</p>

<p>After all you will always end up with writing method for dealing with all items (adding, removing, changing) and starting with this point can let you avoid a lot of problems in future. Also very quick it made you to rewrite your methods and optimize all code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YMNI vs YAGNI]]></title>
    <link href="http://maque.github.io/blog/2014/03/10/ymni-vs-yagni/"/>
    <updated>2014-03-10T17:08:59+00:00</updated>
    <id>http://maque.github.io/blog/2014/03/10/ymni-vs-yagni</id>
    <content type="html"><![CDATA[<p>YAGNI (<strong>You aren&rsquo;t gonna need it</strong>) principle sound nice when you hear it. After all why to bother your self wasting time for something that you probably won&rsquo;t use.
Well, it sounds good only for features or bunch of &ldquo;maybe need&rdquo; methods like getters &amp; setter.</p>

<p>But sometimes you can start excusing your laziness with yagni. For example when you know you need only two categories with items. That&rsquo;s the plan, so it&rsquo;s easy to you just duplicate lists and rename them. It&rsquo;s easier than playing with embedded list, geting header for each of them, specially when you are using some external tools like Kendo UI. And definitely easier when you are working with legacy code.</p>

<p>And then suddenly, client call and he want 20 list for tomorrow. You already did two, can&rsquo;t you just copy and paste 18? I&rsquo;m sure it&rsquo;s like 5min. for you, isn&rsquo;t it?</p>

<p>So You May Need It</p>

<p>If you have already followed YAGNI principle to far it will become hell for you. You didn&rsquo;t write any administration panel, there is no table in database for product type, ale the tables assumes that there are only two product types. It wouldn&rsquo;t be a problem if you were developing in nice &amp; clean scrum/agile/bdd work place with time to analyze every new feature.
But our life isn&rsquo;t so easy. Our PM&rsquo;s not necessary had everything set up with client, sometimes there is no written agreement at all about changes, fixes &amp; features and client IS ALWAYS EXPECTING TO MAKE IT ASAP!
Even if you PM understand you had followed YAGNI principle doesn&rsquo;t mean you can wait with release to next month. Probably they want this change today at 5pm, maybe tomorrow morning.</p>

<p>If you would follow YAGNI really strict you will end up with not layered code, no abstraction and not prepared to any changes. It&rsquo;s not only if you follow this principle standalone, but also if you have continuous refactoring it&rsquo;s still not as good as it sounds.</p>

<p>Reason is simple: Client is always lying.
He lies about changes. He will tell you he need only change logo, but then he reminds himself that also other &ldquo;few minor&rdquo; changes are needed.
He lies about deadline.Very often deadline is fluid, you are waiting for aproval from pm&rsquo;s and directors, each of them want to change &ldquo;only small thing&rdquo;. You never have &ldquo;finished&rdquo; software at the day of realese &ndash; you have only software that director agreed to show to the people.</p>

<p>Also, let be honest, assuming you are working in company &ndash; do you really have time to write bunch of code lines without need for using it? Maybe at the very beginning of project with no legacy code what so ever.</p>

<p>If you found yourself adding manually records to database, because in the last moment client change mind, you know you followed YAGNI to far.</p>

<p>Here are my few tips for working with YAGNI but keeping in mind YMNI</p>

<p><strong>1. Assume you will need release your code 5 times in one day. Each with different set of features. Each for different server.</strong></p>

<p>With this assumption you will prepare really good plan for releases. You will prepare proper source control workflow (git workflow, branch by feature). With this assumption you can&rsquo;t just overwrite/copy&amp;paste files in folder. There is no time for that and there is no space for mistake.You need to have build check &amp; unit test before each release.
Also although your code is clean&amp;perfect doesn&rsquo;t mean you release process is. You spend so much time with IoC, TDD and SOLID that now changing manually connection string after releasing to new server seems good enough. Well, it isn&rsquo;t.</p>

<p><strong>2. Assume you will need add this one setting, role, product, type 100 times more in the future.</strong></p>

<p>You saw this so many times, why now you are believe this will be different?</p>

<p><strong>3. Assume there will be a lot of exceptions and don&rsquo;t make any.</strong></p>

<p>You can start project with set of features, nice and clean, logically composed. But then suddenly client will tell you something like this: &ldquo;Well, we want to show this product the same as it was, but with special sparkling animation, just for this one&rdquo;. Do not believe that! Don&rsquo;t try to put special flag, &ldquo;if&rdquo;, exception, or any other &lsquo;hack&rsquo; just for one item. Remember about doing this 100 times? This is so obvious and yet I saw that so many times.</p>
]]></content>
  </entry>
  
</feed>
